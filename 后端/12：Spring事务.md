不能不知道的认知 - 事务

在企业开发中，通常需要使用事务来保证数据的一致性。在Spring中，事务管理可以通过@Transactional注解来完成。也可以通过编程式事务来进行管理。

`推荐原因:`  确定一下同一个事务内，事务控制和不加事务控制的区别

>一、事务内部操作的可见性（`同一个事务内`）

在同一个事务中，所有的操作是按照顺序执行的，并且这些操作的结果对该事务内的后续操作是可见的。

ps: 事务内的每个操作对于后续操作都是可见的：
- 插入一条记录后，记录在事务内立即可见。
- 更新操作能读取到刚插入的记录，并修改它。
- 删除操作能找到并删除刚更新的记录。
```java
@Transactional
public void performTransaction() {
    // 插入一条记录
    someRepository.save(new SomeEntity("value1"));

    // 更新刚插入的记录
    SomeEntity entity = someRepository.findByValue("value1");
    entity.setValue("value2");
    someRepository.save(entity);

    // 删除刚更新的记录
    someRepository.delete(entity);
}
```
>二、事务的隔离级别产生的脏读、不可重复读和幻读（`同一个事务`）

1、脏读：

在同一个事务中，脏读的情况不会发生，因为事务内部的修改对事务自身总是可见的。脏读问题主要涉及不同事务之间的未提交数据读取。

2、不可重复读：

在同一个事务中，不存在不可重复读的问题，因为事务内部的读取操作总是可以看到自己之前的所有修改。

3、幻读：

在同一个事务中，也不会发生幻读问题，因为事务内部的查询结果总是可以看到自己之前的插入、更新和删除操作。


>三、事务的基本概念
事务（Transaction） 是指 `一组` 操作的集合，这些操作作为一个整体，要么全部执行成功，要么全部执行失败。

事务具有`四大特性（ACID）`：

- 原子性（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成。
- 一致性（Consistency）：事务执行前后，数据库必须处于一致的状态。
- 隔离性（Isolation）：一个事务的执行不应受到其他事务的干扰。
- 持久性（Durability）：一旦事务提交，其结果应永久保存在数据库中。

>四、事务的传播行为

Spring提供了多种事务传播行为来处理不同的事务嵌套情况。`7种传播行为`有：

1、PROPAGATION_REQUIRED（默认值）:
- 如果当前存在事务，则加入当前事务；如果当前没有事务，则创建一个新的事务。
- 这是最常用的传播行为，确保所有的操作都在同一个事务中执行。

2、PROPAGATION_REQUIRES_NEW:
- 创建一个新的事务。如果当前存在事务，则将当前事务挂起。
- 适用于需要独立事务执行的操作，例如记录日志或发送通知。

3、PROPAGATION_SUPPORTS：
- 支持当前事务。如果当前存在事务，则加入当前事务；如果当前没有事务，则以非事务方式执行。
- 适用于既可以在事务中执行，也可以在非事务中执行的操作

4、PROPAGATION_NOT_SUPPORTED
- 以非事务方式执行操作。如果当前存在事务，则将当前事务挂起
- 适用于不需要事务的操作，避免占用事务资源

5、PROPAGATION_NEVER：
- 以非事务方式执行操作。如果当前存在事务，则抛出异常
- 适用于必须在非事务环境中执行的操作

6、PROPAGATION_MANDATORY
- 支持当前事务。如果当前不存在事务，则抛出异常
- 适用于必须在事务中执行的操作

7、PROPAGATION_NESTED
- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则创建一个新的事务
- 嵌套事务有自己的保存点，可以独立回滚，但需要底层数据库支持（如支持保存点的数据库）。

>5、如果觉得对你有点帮助，请点点最下面的关注、点赞、转发、在看。谢谢支持！公众号：`ddtongxiang`在线等你！